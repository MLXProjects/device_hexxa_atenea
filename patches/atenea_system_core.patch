diff --git a/include/netutils/ifc.h b/include/netutils/ifc.h
index 3b27234..ede743c 100644
--- a/include/netutils/ifc.h
+++ b/include/netutils/ifc.h
@@ -61,6 +61,14 @@ extern int ifc_configure(const char *ifname, in_addr_t address,
 
 extern in_addr_t prefixLengthToIpv4Netmask(int prefix_length);
 
+extern int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps);
+
+/* MTK */
+#ifdef MTK_HARDWARE
+extern int ifc_set_txq_state(const char *ifname, int state);
+extern int ifc_ccmni_md_cfg(const char *ifname, int md_id);
+#endif /* MTK_HARDWARE */
+
 __END_DECLS
 
 #endif /* _NETUTILS_IFC_H_ */
diff --git a/init/Android.mk b/init/Android.mk
index c6863bf..a66bbc5 100755
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -29,6 +29,11 @@ ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
 LOCAL_CFLAGS += -DALLOW_LOCAL_PROP_OVERRIDE=1 -DALLOW_DISABLE_SELINUX=1
 endif
 
+# Enable MTK stuff
+ifeq ($(BOARD_HAS_MTK_HARDWARE), true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+endif
+
 # Enable ueventd logging
 #LOCAL_CFLAGS += -DLOG_UEVENTS=1
 
diff --git a/init/init.c b/init/init.c
index 1cce8d8..0d03483 100644
--- a/init/init.c
+++ b/init/init.c
@@ -1010,7 +1010,11 @@ static void selinux_initialize(void)
     }
 
     selinux_init_all_handles();
+#ifdef MTK_HARDWARE
+    bool is_enforcing = false; // Always making selinux permissive for MTK's rild
+#else
     bool is_enforcing = selinux_is_enforcing();
+#endif
     INFO("SELinux: security_setenforce(%d)\n", is_enforcing);
     security_setenforce(is_enforcing);
 }
diff --git a/libnetutils/ifc_utils.c b/libnetutils/ifc_utils.c
index cb3722d..c9c6c1e 100644
--- a/libnetutils/ifc_utils.c
+++ b/libnetutils/ifc_utils.c
@@ -36,6 +36,7 @@
 #include <linux/ipv6_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/sockios.h>
+#include <linux/un.h>
 
 #include "netutils/ifc.h"
 
@@ -711,3 +712,139 @@ ifc_configure(const char *ifname,
 
     return 0;
 }
+
+static int ifc_netd_sock_init(void)
+{
+    int ifc_netd_sock;
+    const int one = 1;
+    struct sockaddr_un netd_addr;
+  
+        ifc_netd_sock = socket(AF_UNIX, SOCK_STREAM, 0);
+        if (ifc_netd_sock < 0) {
+            printerr("ifc_netd_sock_init: create socket failed");
+            return -1;
+        }
+  
+        setsockopt(ifc_netd_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+        memset(&netd_addr, 0, sizeof(netd_addr));
+        netd_addr.sun_family = AF_UNIX;
+        strlcpy(netd_addr.sun_path, "/dev/socket/netd",
+            sizeof(netd_addr.sun_path));
+        if (TEMP_FAILURE_RETRY(connect(ifc_netd_sock,
+                     (const struct sockaddr*) &netd_addr,
+                     sizeof(netd_addr))) != 0) {
+            printerr("ifc_netd_sock_init: connect to netd failed, fd=%d, err: %d(%s)", 
+                ifc_netd_sock, errno, strerror(errno));
+            close(ifc_netd_sock);
+            return -1;
+        }
+  
+    if (DBG) printerr("ifc_netd_sock_init fd=%d", ifc_netd_sock);
+    return ifc_netd_sock;
+}
+
+/*do not call this function in netd*/
+int ifc_set_throttle(const char *ifname, int rxKbps, int txKbps)
+{
+    FILE* fnetd = NULL;
+    int ret = -1;
+    int seq = 1;
+    char rcv_buf[24];
+	int nread = 0;
+	int netd_sock = 0;
+	
+    ALOGD("enter ifc_set_throttle: ifname = %s, rx = %d kbs, tx = %d kbs", ifname, rxKbps, txKbps);
+
+    netd_sock = ifc_netd_sock_init();
+    if(netd_sock <= 0)
+        goto exit;
+    
+    // Send the request.
+    fnetd = fdopen(netd_sock, "r+");
+	if(fnetd == NULL){
+		ALOGE("open netd socket failed, err:%d(%s)", errno, strerror(errno));
+		goto exit;
+	}
+    if (fprintf(fnetd, "%d interface setthrottle %s %d %d", seq, ifname, rxKbps, txKbps) < 0) {
+        goto exit;
+    }
+    // literal NULL byte at end, required by FrameworkListener
+    if (fputc(0, fnetd) == EOF ||
+        fflush(fnetd) != 0) {
+        goto exit;
+    }
+    ret = 0;
+
+	//Todo: read the whole response from netd
+	nread = fread(rcv_buf, 1, 20, fnetd);
+	rcv_buf[23] = 0;
+	ALOGD("response: %s", rcv_buf);
+exit:
+    if (fnetd != NULL) {
+        fclose(fnetd);
+    }
+  
+    return ret;
+}
+
+
+/* MTK */
+#ifdef MTK_HARDWARE
+
+#define SIOCSTXQSTATE (SIOCDEVPRIVATE + 0)  //start/stop ccmni tx queue
+#define SIOCSCCMNICFG (SIOCDEVPRIVATE + 1)  //configure ccmni/md remapping
+
+int ifc_set_txq_state(const char *ifname, int state)
+{
+    struct ifreq ifr;
+    int ret, ctl_sock;
+
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    ifr.ifr_name[IFNAMSIZ - 1] = 0;
+    ifr.ifr_ifru.ifru_ivalue = state;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        ALOGE("create ctl socket failed\n");
+        return -1;
+    }
+    ret = ioctl(ctl_sock, SIOCSTXQSTATE, &ifr);
+    if(ret < 0)
+        ALOGE("ifc_set_txq_state failed, err:%d(%s)\n", errno, strerror(errno));
+    else
+        ALOGI("ifc_set_txq_state as %d, ret: %d\n", state, ret);
+
+    close(ctl_sock);
+
+    return ret;
+}
+
+int ifc_ccmni_md_cfg(const char *ifname, int md_id)
+{
+    struct ifreq ifr;
+    int ret = 0;
+    int ctl_sock = 0;
+
+    ifc_init_ifr(ifname, &ifr);
+    ifr.ifr_ifru.ifru_ivalue = md_id;
+
+    ctl_sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(ctl_sock < 0){
+        printerr("ifc_ccmni_md_cfg: create ctl socket failed\n");
+        return -1;
+    }
+
+    if(ioctl(ctl_sock, SIOCSCCMNICFG, &ifr) < 0) {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) error:%d(%s)", \
+            ifname, md_id, errno, strerror(errno));
+        ret = -1;
+    } else {
+        printerr("ifc_ccmni_md_configure(ifname=%s, md_id=%d) OK", ifname, md_id);
+    }
+
+    close(ctl_sock);
+    return ret;
+}
+
+#endif /* MTK_HARDWARE */
diff --git a/libutils/Android.mk b/libutils/Android.mk
index 035846b..2acbbea 100644
--- a/libutils/Android.mk
+++ b/libutils/Android.mk
@@ -84,13 +84,17 @@ include $(CLEAR_VARS)
 LOCAL_SRC_FILES:= \
 	$(commonSources) \
 	Looper.cpp \
-	Trace.cpp
+	Trace.cpp 
 
 ifeq ($(TARGET_ARCH),mips)
 LOCAL_CFLAGS += -DALIGN_DOUBLE
 endif
 LOCAL_CFLAGS += -Werror
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)  
+LOCAL_SRC_FILES += MediatekHacks.cpp  
+endif 
+
 LOCAL_C_INCLUDES += \
 		bionic/libc \
 		external/zlib
diff --git a/libutils/MediatekHacks.cpp b/libutils/MediatekHacks.cpp
index e69de29..40c6678 100644
--- a/libutils/MediatekHacks.cpp
+++ b/libutils/MediatekHacks.cpp
@@ -0,0 +1,19 @@
+extern "C" {
+void _ZN7android11IDumpTunnel11asInterfaceERKNS_2spINS_7IBinderEEE(){}
+void _ZN7android11BufferQueueC1ERKNS_2spINS_19IGraphicBufferAllocEEE(){}
+void _ZN7android22IGraphicBufferConsumer10BufferItemC1Ev(){}
+void _ZN7android9CallStackC1EPKci(char const*, int);
+void _ZN7android9CallStack6updateEii(int, int);
+
+void _ZN7android9CallStackC1EPKcii(char const* logtag, int ignoreDepth, int maxDepth){
+ maxDepth = maxDepth-1;
+ maxDepth = maxDepth+1;
+ _ZN7android9CallStackC1EPKci(logtag, ignoreDepth);
+}
+
+void _ZN7android9CallStack6updateEiii(int ignoreDepth, int maxDepth, int tid){
+ maxDepth = maxDepth-1;
+ maxDepth = maxDepth+1; 
+ _ZN7android9CallStack6updateEii(ignoreDepth, tid);
+}
+}
