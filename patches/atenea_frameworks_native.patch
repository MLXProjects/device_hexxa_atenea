diff --git a/include/gui/BufferQueue.h b/include/gui/BufferQueue.h
index 6b9be5d..f7a03f0 100644
--- a/include/gui/BufferQueue.h
+++ b/include/gui/BufferQueue.h
@@ -17,18 +17,56 @@
 #ifndef ANDROID_GUI_BUFFERQUEUE_H
 #define ANDROID_GUI_BUFFERQUEUE_H
 
-#include <gui/BufferQueueDefs.h>
-#include <gui/IGraphicBufferConsumer.h>
-#include <gui/IGraphicBufferProducer.h>
+#include <gui/BufferQueueProducer.h>
+#include <gui/BufferQueueConsumer.h>
 #include <gui/IConsumerListener.h>
 
 // These are only required to keep other parts of the framework with incomplete
 // dependencies building successfully
 #include <gui/IGraphicBufferAlloc.h>
 
+#include <binder/IBinder.h>
+#include <utils/Condition.h>
+
 namespace android {
 
-class BufferQueue {
+// BQProducer and BQConsumer are thin shim classes to allow methods with the
+// same signature in both IGraphicBufferProducer and IGraphicBufferConsumer.
+// This will stop being an issue when we deprecate creating BufferQueues
+// directly (as opposed to using the *Producer and *Consumer interfaces).
+class BQProducer : public BnGraphicBufferProducer {
+public:
+    virtual status_t detachProducerBuffer(int slot) = 0;
+    virtual status_t attachProducerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer) = 0;
+
+    virtual status_t detachBuffer(int slot) {
+        return detachProducerBuffer(slot);
+    }
+
+    virtual status_t attachBuffer(int* slot, const sp<GraphicBuffer>& buffer) {
+        return attachProducerBuffer(slot, buffer);
+    }
+};
+
+class BQConsumer : public BnGraphicBufferConsumer {
+public:
+    virtual status_t detachConsumerBuffer(int slot) = 0;
+    virtual status_t attachConsumerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer) = 0;
+
+    virtual status_t detachBuffer(int slot) {
+        return detachConsumerBuffer(slot);
+    }
+
+    virtual status_t attachBuffer(int* slot, const sp<GraphicBuffer>& buffer) {
+        return attachConsumerBuffer(slot, buffer);
+    }
+};
+
+class BufferQueue : public BQProducer,
+                    public BQConsumer,
+                    private IBinder::DeathRecipient {
 public:
     // BufferQueue will keep track of at most this value of buffers.
     // Attempts at runtime to increase the number of buffers past this will fail.
@@ -47,7 +85,6 @@ public:
 
     // for backward source compatibility
     typedef ::android::ConsumerListener ConsumerListener;
-    typedef IGraphicBufferConsumer::BufferItem BufferItem;
 
     // ProxyConsumerListener is a ConsumerListener implementation that keeps a weak
     // reference to the actual consumer object.  It forwards all calls to that
@@ -74,11 +111,273 @@ public:
     // BufferQueue manages a pool of gralloc memory slots to be used by
     // producers and consumers. allocator is used to allocate all the
     // needed gralloc buffers.
+
+    BufferQueue(const sp<IGraphicBufferAlloc>& allocator = NULL);
+
     static void createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
             sp<IGraphicBufferConsumer>* outConsumer,
             const sp<IGraphicBufferAlloc>& allocator = NULL);
+
+    virtual ~BufferQueue();
+
+    /*
+     * IBinder::DeathRecipient interface
+     */
+
+    virtual void binderDied(const wp<IBinder>& who);
+
+    /*
+     * IGraphicBufferProducer interface
+     */
+
+    // Query native window attributes.  The "what" values are enumerated in
+    // window.h (e.g. NATIVE_WINDOW_FORMAT).
+    virtual int query(int what, int* value);
+
+    // setBufferCount updates the number of available buffer slots.  If this
+    // method succeeds, buffer slots will be both unallocated and owned by
+    // the BufferQueue object (i.e. they are not owned by the producer or
+    // consumer).
+    //
+    // This will fail if the producer has dequeued any buffers, or if
+    // bufferCount is invalid.  bufferCount must generally be a value
+    // between the minimum undequeued buffer count (exclusive) and NUM_BUFFER_SLOTS
+    // (inclusive).  It may also be set to zero (the default) to indicate
+    // that the producer does not wish to set a value.  The minimum value
+    // can be obtained by calling query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
+    // ...).
+    //
+    // This may only be called by the producer.  The consumer will be told
+    // to discard buffers through the onBuffersReleased callback.
+    virtual status_t setBufferCount(int bufferCount);
+
+    // requestBuffer returns the GraphicBuffer for slot N.
+    //
+    // In normal operation, this is called the first time slot N is returned
+    // by dequeueBuffer.  It must be called again if dequeueBuffer returns
+    // flags indicating that previously-returned buffers are no longer valid.
+    virtual status_t requestBuffer(int slot, sp<GraphicBuffer>* buf);
+
+    // dequeueBuffer gets the next buffer slot index for the producer to use.
+    // If a buffer slot is available then that slot index is written to the
+    // location pointed to by the buf argument and a status of OK is returned.
+    // If no slot is available then a status of -EBUSY is returned and buf is
+    // unmodified.
+    //
+    // The fence parameter will be updated to hold the fence associated with
+    // the buffer. The contents of the buffer must not be overwritten until the
+    // fence signals. If the fence is Fence::NO_FENCE, the buffer may be
+    // written immediately.
+    //
+    // The width and height parameters must be no greater than the minimum of
+    // GL_MAX_VIEWPORT_DIMS and GL_MAX_TEXTURE_SIZE (see: glGetIntegerv).
+    // An error due to invalid dimensions might not be reported until
+    // updateTexImage() is called.  If width and height are both zero, the
+    // default values specified by setDefaultBufferSize() are used instead.
+    //
+    // The pixel formats are enumerated in graphics.h, e.g.
+    // HAL_PIXEL_FORMAT_RGBA_8888.  If the format is 0, the default format
+    // will be used.
+    //
+    // The usage argument specifies gralloc buffer usage flags.  The values
+    // are enumerated in gralloc.h, e.g. GRALLOC_USAGE_HW_RENDER.  These
+    // will be merged with the usage flags specified by setConsumerUsageBits.
+    //
+    // The return value may be a negative error value or a non-negative
+    // collection of flags.  If the flags are set, the return values are
+    // valid, but additional actions must be performed.
+    //
+    // If IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION is set, the
+    // producer must discard cached GraphicBuffer references for the slot
+    // returned in buf.
+    // If IGraphicBufferProducer::RELEASE_ALL_BUFFERS is set, the producer
+    // must discard cached GraphicBuffer references for all slots.
+    //
+    // In both cases, the producer will need to call requestBuffer to get a
+    // GraphicBuffer handle for the returned slot.
+    virtual status_t dequeueBuffer(int *buf, sp<Fence>* fence, bool async,
+            uint32_t width, uint32_t height, uint32_t format, uint32_t usage);
+
+    // See IGraphicBufferProducer::detachBuffer
+    virtual status_t detachProducerBuffer(int slot);
+
+    // See IGraphicBufferProducer::detachNextBuffer
+    virtual status_t detachNextBuffer(sp<GraphicBuffer>* outBuffer,
+            sp<Fence>* outFence);
+
+    // See IGraphicBufferProducer::attachBuffer
+    virtual status_t attachProducerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer);
+
+    // queueBuffer returns a filled buffer to the BufferQueue.
+    //
+    // Additional data is provided in the QueueBufferInput struct.  Notably,
+    // a timestamp must be provided for the buffer. The timestamp is in
+    // nanoseconds, and must be monotonically increasing. Its other semantics
+    // (zero point, etc) are producer-specific and should be documented by the
+    // producer.
+    //
+    // The caller may provide a fence that signals when all rendering
+    // operations have completed.  Alternatively, NO_FENCE may be used,
+    // indicating that the buffer is ready immediately.
+    //
+    // Some values are returned in the output struct: the current settings
+    // for default width and height, the current transform hint, and the
+    // number of queued buffers.
+    virtual status_t queueBuffer(int buf,
+            const QueueBufferInput& input, QueueBufferOutput* output);
+
+    // cancelBuffer returns a dequeued buffer to the BufferQueue, but doesn't
+    // queue it for use by the consumer.
+    //
+    // The buffer will not be overwritten until the fence signals.  The fence
+    // will usually be the one obtained from dequeueBuffer.
+    virtual void cancelBuffer(int buf, const sp<Fence>& fence);
+
+    // See IGraphicBufferProducer::connect
+    virtual status_t connect(const sp<IProducerListener>& listener,
+            int api, bool producerControlledByApp, QueueBufferOutput* output);
+
+    // disconnect attempts to disconnect a producer API from the BufferQueue.
+    // Calling this method will cause any subsequent calls to other
+    // IGraphicBufferProducer methods to fail except for getAllocator and connect.
+    // Successfully calling connect after this will allow the other methods to
+    // succeed again.
+    //
+    // This method will fail if the the BufferQueue is not currently
+    // connected to the specified producer API.
+    virtual status_t disconnect(int api);
+
+    // Attaches a sideband buffer stream to the BufferQueue.
+    //
+    // A sideband stream is a device-specific mechanism for passing buffers
+    // from the producer to the consumer without using dequeueBuffer/
+    // queueBuffer. If a sideband stream is present, the consumer can choose
+    // whether to acquire buffers from the sideband stream or from the queued
+    // buffers.
+    //
+    // Passing NULL or a different stream handle will detach the previous
+    // handle if any.
+    virtual status_t setSidebandStream(const sp<NativeHandle>& stream);
+
+    /*
+     * IGraphicBufferConsumer interface
+     */
+
+    // acquireBuffer attempts to acquire ownership of the next pending buffer in
+    // the BufferQueue.  If no buffer is pending then it returns NO_BUFFER_AVAILABLE. If a
+    // buffer is successfully acquired, the information about the buffer is
+    // returned in BufferItem.  If the buffer returned had previously been
+    // acquired then the BufferItem::mGraphicBuffer field of buffer is set to
+    // NULL and it is assumed that the consumer still holds a reference to the
+    // buffer.
+    //
+    // If presentWhen is nonzero, it indicates the time when the buffer will
+    // be displayed on screen.  If the buffer's timestamp is farther in the
+    // future, the buffer won't be acquired, and PRESENT_LATER will be
+    // returned.  The presentation time is in nanoseconds, and the time base
+    // is CLOCK_MONOTONIC.
+    virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen);
+
+    // See IGraphicBufferConsumer::detachBuffer
+    virtual status_t detachConsumerBuffer(int slot);
+
+    // See IGraphicBufferConsumer::attachBuffer
+    virtual status_t attachConsumerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer);
+
+    // releaseBuffer releases a buffer slot from the consumer back to the
+    // BufferQueue.  This may be done while the buffer's contents are still
+    // being accessed.  The fence will signal when the buffer is no longer
+    // in use. frameNumber is used to indentify the exact buffer returned.
+    //
+    // If releaseBuffer returns STALE_BUFFER_SLOT, then the consumer must free
+    // any references to the just-released buffer that it might have, as if it
+    // had received a onBuffersReleased() call with a mask set for the released
+    // buffer.
+    //
+    // Note that the dependencies on EGL will be removed once we switch to using
+    // the Android HW Sync HAL.
+    virtual status_t releaseBuffer(int buf, uint64_t frameNumber,
+            EGLDisplay display, EGLSyncKHR fence,
+            const sp<Fence>& releaseFence);
+
+    // consumerConnect connects a consumer to the BufferQueue.  Only one
+    // consumer may be connected, and when that consumer disconnects the
+    // BufferQueue is placed into the "abandoned" state, causing most
+    // interactions with the BufferQueue by the producer to fail.
+    // controlledByApp indicates whether the consumer is controlled by
+    // the application.
+    //
+    // consumer may not be NULL.
+    virtual status_t consumerConnect(const sp<IConsumerListener>& consumer, bool controlledByApp);
+
+    // consumerDisconnect disconnects a consumer from the BufferQueue. All
+    // buffers will be freed and the BufferQueue is placed in the "abandoned"
+    // state, causing most interactions with the BufferQueue by the producer to
+    // fail.
+    virtual status_t consumerDisconnect();
+
+    // getReleasedBuffers sets the value pointed to by slotMask to a bit mask
+    // indicating which buffer slots have been released by the BufferQueue
+    // but have not yet been released by the consumer.
+    //
+    // This should be called from the onBuffersReleased() callback.
+    virtual status_t getReleasedBuffers(uint64_t* slotMask);
+
+    // setDefaultBufferSize is used to set the size of buffers returned by
+    // dequeueBuffer when a width and height of zero is requested.  Default
+    // is 1x1.
+    virtual status_t setDefaultBufferSize(uint32_t w, uint32_t h);
+
+    // setDefaultMaxBufferCount sets the default value for the maximum buffer
+    // count (the initial default is 2). If the producer has requested a
+    // buffer count using setBufferCount, the default buffer count will only
+    // take effect if the producer sets the count back to zero.
+    //
+    // The count must be between 2 and NUM_BUFFER_SLOTS, inclusive.
+    virtual status_t setDefaultMaxBufferCount(int bufferCount);
+
+    // disableAsyncBuffer disables the extra buffer used in async mode
+    // (when both producer and consumer have set their "isControlledByApp"
+    // flag) and has dequeueBuffer() return WOULD_BLOCK instead.
+    //
+    // This can only be called before consumerConnect().
+    virtual status_t disableAsyncBuffer();
+
+    // setMaxAcquiredBufferCount sets the maximum number of buffers that can
+    // be acquired by the consumer at one time (default 1).  This call will
+    // fail if a producer is connected to the BufferQueue.
+    virtual status_t setMaxAcquiredBufferCount(int maxAcquiredBuffers);
+
+    // setConsumerName sets the name used in logging
+    virtual void setConsumerName(const String8& name);
+
+    // setDefaultBufferFormat allows the BufferQueue to create
+    // GraphicBuffers of a defaultFormat if no format is specified
+    // in dequeueBuffer.  Formats are enumerated in graphics.h; the
+    // initial default is HAL_PIXEL_FORMAT_RGBA_8888.
+    virtual status_t setDefaultBufferFormat(uint32_t defaultFormat);
+
+    // setConsumerUsageBits will turn on additional usage bits for dequeueBuffer.
+    // These are merged with the bits passed to dequeueBuffer.  The values are
+    // enumerated in gralloc.h, e.g. GRALLOC_USAGE_HW_RENDER; the default is 0.
+    virtual status_t setConsumerUsageBits(uint32_t usage);
+
+    // setTransformHint bakes in rotation to buffers so overlays can be used.
+    // The values are enumerated in window.h, e.g.
+    // NATIVE_WINDOW_TRANSFORM_ROT_90.  The default is 0 (no transform).
+    virtual status_t setTransformHint(uint32_t hint);
+
+    // Retrieve the BufferQueue's sideband stream, if any.
+    virtual sp<NativeHandle> getSidebandStream() const;
+
+    // dump our state in a String
+    virtual void dump(String8& result, const char* prefix) const;
+
 private:
-    BufferQueue(); // Create through createBufferQueue
+    sp<BufferQueueProducer> mProducer;
+    sp<BufferQueueConsumer> mConsumer;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/gui/BufferQueueProducer.h b/include/gui/BufferQueueProducer.h
index c0c8e6d..4beaf05 100644
--- a/include/gui/BufferQueueProducer.h
+++ b/include/gui/BufferQueueProducer.h
@@ -19,6 +19,7 @@
 
 #include <gui/BufferQueueDefs.h>
 #include <gui/IGraphicBufferProducer.h>
+#include <utils/Condition.h>
 
 namespace android {
 
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index 20466b6..6a63750 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -110,6 +110,12 @@ private:
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
+
+#ifdef MTK_HARDWARE
+private:
+    void dump(int fd);
+#endif
+
 };
 
 }; // namespace android
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index 0ffc582..4afa42f 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -71,6 +71,14 @@ private:
     gralloc_module_t const *mAllocMod;
 };
 
+#ifdef MTK_HARDWARE
+extern "C" {
+
+    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
+            buffer_handle_t handle, int usage, const Rect& bounds, void** vaddr);
+
+}
+#endif
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
index e69de29..4ab32da 100644
--- a/include/ui/mediatek/IDumpTunnel.h
+++ b/include/ui/mediatek/IDumpTunnel.h
@@ -0,0 +1,50 @@
+#ifndef ANDROID_GUI_IDUMPTUNNEL_H
+#define ANDROID_GUI_IDUMPTUNNEL_H
+
+#include <binder/IInterface.h>
+#include <utils/Singleton.h>
+
+namespace android
+{
+
+class IDumpTunnel : public IInterface {
+protected:
+    enum {
+        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
+    };
+
+public:
+    DECLARE_META_INTERFACE(DumpTunnel);
+
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
+};
+
+class BnDumpTunnel : public BnInterface<IDumpTunnel>
+{
+    virtual status_t onTransact(uint32_t code,
+                                const Parcel& data,
+                                Parcel* reply,
+                                uint32_t flags = 0);
+};
+
+// helper class for libgui_ext dynamic linking
+class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
+    void* mSoHandle;
+    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
+    bool (*mUnregDumpPtr)(const String8&);
+
+public:
+    DumpTunnelHelper();
+    virtual ~DumpTunnelHelper();
+
+    // register tunnel into guiext-server with a given key name
+    // and need to unregister it back
+    // in general usage, need to use identical key name for reg/unreg pair
+    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
+    bool unregDump(const String8& key);
+};
+
+
+};
+#endif
+
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
index e69de29..a6a483d 100644
--- a/include/ui/mediatek/RefBaseDump.h
+++ b/include/ui/mediatek/RefBaseDump.h
@@ -0,0 +1,64 @@
+#ifndef ANDROID_REFBASE_DUMP_H__
+#define ANDROID_REFBASE_DUMP_H__
+
+#include <utils/String8.h>
+#include <utils/KeyedVector.h>
+#include <utils/Singleton.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android
+{
+class RefBaseMonitor;
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+class RefBaseDump : public BnDumpTunnel {
+
+public:
+    RefBaseDump(RefBaseMonitor*);
+    virtual ~RefBaseDump();
+
+    // IDumpTunnel interface
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/);
+
+private:
+    RefBaseMonitor *mMonitor;
+};
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+class RefBaseMonitor : public Singleton<RefBaseMonitor> {
+public:
+    RefBaseMonitor();
+    virtual ~RefBaseMonitor();
+
+    // add refbase to the monitored list
+    status_t monitor(RefBase* );
+
+    // remove refbase from the monitored list
+    status_t unmonitor(RefBase* );
+
+    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
+    status_t dump(String8& result);
+
+private:
+    status_t getProcessName();
+
+    // if trackMe needed
+    bool mIsTracking;
+
+    String8 mProcessName;
+
+    sp<RefBaseDump> mDump;
+
+    // the list where monitored refbase objects are saved
+    KeyedVector<RefBase*,int> RbList;
+
+    mutable Mutex mMutex;;
+};
+
+};
+#endif
+
diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index 61fd8c4..fcca07a 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -19,9 +19,7 @@
 //#define LOG_NDEBUG 0
 
 #include <gui/BufferQueue.h>
-#include <gui/BufferQueueConsumer.h>
 #include <gui/BufferQueueCore.h>
-#include <gui/BufferQueueProducer.h>
 
 namespace android {
 
@@ -46,13 +44,6 @@ void BufferQueue::ProxyConsumerListener::onBuffersReleased() {
     }
 }
 
-void BufferQueue::ProxyConsumerListener::onSidebandStreamChanged() {
-    sp<ConsumerListener> listener(mConsumerListener.promote());
-    if (listener != NULL) {
-        listener->onSidebandStreamChanged();
-    }
-}
-
 void BufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
         sp<IGraphicBufferConsumer>* outConsumer,
         const sp<IGraphicBufferAlloc>& allocator) {
@@ -77,4 +68,151 @@ void BufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
     *outConsumer = consumer;
 }
 
+BufferQueue::BufferQueue(const sp<IGraphicBufferAlloc>& allocator) :
+    mProducer(),
+    mConsumer()
+{
+    sp<BufferQueueCore> core(new BufferQueueCore(allocator));
+    mProducer = new BufferQueueProducer(core);
+    mConsumer = new BufferQueueConsumer(core);
+}
+
+BufferQueue::~BufferQueue() {}
+
+void BufferQueue::binderDied(const wp<IBinder>& who) {
+    mProducer->binderDied(who);
+}
+
+int BufferQueue::query(int what, int* outValue) {
+    return mProducer->query(what, outValue);
+}
+
+status_t BufferQueue::setBufferCount(int bufferCount) {
+    return mProducer->setBufferCount(bufferCount);
+}
+
+status_t BufferQueue::requestBuffer(int slot, sp<GraphicBuffer>* buf) {
+    return mProducer->requestBuffer(slot, buf);
+}
+
+status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>* outFence, bool async,
+        uint32_t w, uint32_t h, uint32_t format, uint32_t usage) {
+    return mProducer->dequeueBuffer(outBuf, outFence, async, w, h, format, usage);
+}
+
+status_t BufferQueue::detachProducerBuffer(int slot) {
+    return mProducer->detachBuffer(slot);
+}
+
+status_t BufferQueue::detachNextBuffer(sp<GraphicBuffer>* outBuffer,
+        sp<Fence>* outFence) {
+    return mProducer->detachNextBuffer(outBuffer, outFence);
+}
+
+status_t BufferQueue::attachProducerBuffer(int* slot,
+        const sp<GraphicBuffer>& buffer) {
+    return mProducer->attachBuffer(slot, buffer);
+}
+
+status_t BufferQueue::queueBuffer(int buf,
+        const QueueBufferInput& input, QueueBufferOutput* output) {
+    return mProducer->queueBuffer(buf, input, output);
+}
+
+void BufferQueue::cancelBuffer(int buf, const sp<Fence>& fence) {
+    mProducer->cancelBuffer(buf, fence);
+}
+
+status_t BufferQueue::connect(const sp<IProducerListener>& listener,
+        int api, bool producerControlledByApp, QueueBufferOutput* output) {
+    return mProducer->connect(listener, api, producerControlledByApp, output);
+}
+
+status_t BufferQueue::disconnect(int api) {
+    return mProducer->disconnect(api);
+}
+
+status_t BufferQueue::setSidebandStream(const sp<NativeHandle>& stream) {
+    return mProducer->setSidebandStream(stream);
+}
+
+status_t BufferQueue::acquireBuffer(BufferItem* buffer, nsecs_t presentWhen) {
+    return mConsumer->acquireBuffer(buffer, presentWhen);
+}
+
+status_t BufferQueue::detachConsumerBuffer(int slot) {
+    return mConsumer->detachBuffer(slot);
+}
+
+status_t BufferQueue::attachConsumerBuffer(int* slot,
+        const sp<GraphicBuffer>& buffer) {
+    return mConsumer->attachBuffer(slot, buffer);
+}
+
+status_t BufferQueue::releaseBuffer(
+        int buf, uint64_t frameNumber, EGLDisplay display,
+        EGLSyncKHR eglFence, const sp<Fence>& fence) {
+    return mConsumer->releaseBuffer(buf, frameNumber, fence, display, eglFence);
+}
+
+status_t BufferQueue::consumerConnect(const sp<IConsumerListener>& consumerListener,
+        bool controlledByApp) {
+    return mConsumer->connect(consumerListener, controlledByApp);
+}
+
+status_t BufferQueue::consumerDisconnect() {
+    return mConsumer->disconnect();
+}
+
+status_t BufferQueue::getReleasedBuffers(uint64_t* slotMask) {
+    return mConsumer->getReleasedBuffers(slotMask);
+}
+
+status_t BufferQueue::setDefaultBufferSize(uint32_t w, uint32_t h) {
+    return mConsumer->setDefaultBufferSize(w, h);
+}
+
+status_t BufferQueue::setDefaultMaxBufferCount(int bufferCount) {
+    return mConsumer->setDefaultMaxBufferCount(bufferCount);
+}
+
+status_t BufferQueue::disableAsyncBuffer() {
+    return mConsumer->disableAsyncBuffer();
+}
+
+status_t BufferQueue::setMaxAcquiredBufferCount(int maxAcquiredBuffers) {
+    return mConsumer->setMaxAcquiredBufferCount(maxAcquiredBuffers);
+}
+
+void BufferQueue::setConsumerName(const String8& name) {
+    mConsumer->setConsumerName(name);
+}
+
+status_t BufferQueue::setDefaultBufferFormat(uint32_t defaultFormat) {
+    return mConsumer->setDefaultBufferFormat(defaultFormat);
+}
+
+status_t BufferQueue::setConsumerUsageBits(uint32_t usage) {
+    return mConsumer->setConsumerUsageBits(usage);
+}
+
+status_t BufferQueue::setTransformHint(uint32_t hint) {
+    return mConsumer->setTransformHint(hint);
+}
+
+sp<NativeHandle> BufferQueue::getSidebandStream() const {
+    return mConsumer->getSidebandStream();
+}
+
+void BufferQueue::dump(String8& result, const char* prefix) const {
+    mConsumer->dump(result, prefix);
+}
+
+void BufferQueue::ProxyConsumerListener::onSidebandStreamChanged() {
+    sp<ConsumerListener> listener(mConsumerListener.promote());
+    if (listener != NULL) {
+        listener->onSidebandStreamChanged();
+    }
+}
+
 }; // namespace android
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
index e69de29..bb47e41 100644
--- a/libs/ui/mediatek/Fence.cpp
+++ b/libs/ui/mediatek/Fence.cpp
@@ -0,0 +1,60 @@
+#define LOG_TAG "Fence"
+
+#include <sync/sync.h>
+#include <ui/Fence.h>
+#include <unistd.h>
+
+#include <cutils/log.h>
+
+// ---------------------------------------------------------------------------
+
+const char* findKeyWord(const char* msg) {
+    android::String8 obj_name(msg);
+    obj_name.toLower();
+    const char* OBJ_NAME = obj_name.string();
+
+    // NOTE: keep these keywords in sync with MOF
+    android::String8 keyword("timeline_");
+    if (strstr(OBJ_NAME, "surfaceflinger")) {
+        keyword.append("SurfaceFlinger");
+    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
+        keyword.append("ovl_timeline");
+    } else if (strstr(OBJ_NAME, "mali")) {
+        keyword.append("mali");
+    }
+
+    return keyword.string();
+}
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+void Fence::dump(int fd) {
+    if (-1 == fd) return;
+
+    struct sync_fence_info_data *info = sync_fence_info(fd);
+    if (info) {
+        struct sync_pt_info *pt_info = NULL;
+        // status: active(0) signaled(1) error(<0)
+        ALOGD("fence(%s) status(%d)", info->name, info->status);
+
+        // iterate active/error sync points
+        while ((pt_info = sync_pt_info(info, pt_info))) {
+            if (NULL != pt_info && pt_info->status <= 0) {
+                int ts_sec = pt_info->timestamp_ns / 1000000000LL;
+                int ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
+
+                String8 msg = String8::format(
+                    "sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%d.%06d)",
+                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
+                    *(uint32_t *)pt_info->driver_data, ts_sec, ts_usec);
+                ALOGD("%s", msg.string());
+            }
+        }
+        sync_fence_info_free(info);
+    }
+}
+
+} // namespace android
+
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
index e69de29..a80857a 100644
--- a/libs/ui/mediatek/IDumpTunnel.cpp
+++ b/libs/ui/mediatek/IDumpTunnel.cpp
@@ -0,0 +1,115 @@
+#define LOG_TAG "DumpTunnel"
+
+#include <dlfcn.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <cutils/log.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android {
+
+// client : proxy GuiEx class
+class BpDumpTunnel : public BpInterface<IDumpTunnel> {
+public:
+    BpDumpTunnel(const sp<IBinder>& impl)
+        :   BpInterface<IDumpTunnel>(impl) {
+    }
+
+    virtual status_t kickDump(String8& result, const char* prefix) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
+        data.writeString8(result);
+        data.writeCString(prefix);
+        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
+        if (err != NO_ERROR) {
+            ALOGE("kickDump could not contact remote\n");
+            return err;
+        }
+        result = reply.readString8();
+        err = reply.readInt32();
+        return err;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
+
+status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
+    switch (code) {
+        case DUMPTUNNEL_DUMP: {
+            CHECK_INTERFACE(IDumpTunnel, data, reply);
+            String8 result;
+            const char* prefix = NULL;
+            result = data.readString8();
+            prefix = data.readCString();
+
+            status_t ret = kickDump(result, prefix);
+            reply->writeString8(result);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        } break;
+    }
+    return BBinder::onTransact(code, data, reply, flags);
+}
+
+// ----------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
+
+DumpTunnelHelper::DumpTunnelHelper() :
+    mSoHandle(NULL),
+    mRegDumpPtr(NULL),
+    mUnregDumpPtr(NULL)
+{
+    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
+    typedef bool (*UnregDumpPrototype)(const String8&);
+
+    // dlopen must set RTLD_LAZY flag because of performance issue
+    // need to use different path for 32/64 env
+#ifdef __LP64__
+    mSoHandle = dlopen("/system/lib64/libgui_ext.so", RTLD_LAZY);
+#else
+    mSoHandle = dlopen("/system/lib/libgui_ext.so", RTLD_LAZY);
+#endif
+    if (mSoHandle) {
+        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
+        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
+        if (NULL == mRegDumpPtr) {
+            ALOGE("finding regDump() failed");
+        }
+        if (NULL == mUnregDumpPtr) {
+            ALOGE("finding unregDump() failed");
+        }
+    } else {
+        ALOGE("open libgui_ext failed");
+    }
+}
+
+DumpTunnelHelper::~DumpTunnelHelper() {
+    if(mSoHandle != NULL)
+        dlclose(mSoHandle);
+}
+
+bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
+    bool result = false;
+    if (NULL == mRegDumpPtr) {
+        ALOGE("finding regDump() failed");
+        return result;
+    }
+    result = mRegDumpPtr(tunnel, key);
+
+    return result;
+}
+
+bool DumpTunnelHelper::unregDump(const String8& key) {
+    bool result = false;
+    if (NULL == mUnregDumpPtr) {
+        ALOGE("finding unregDump() failed");
+        return result;
+    }
+    result = mUnregDumpPtr(key);
+
+    return result;
+}
+
+};
+
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
index e69de29..cfe29a1 100644
--- a/libs/ui/mediatek/RefBaseDump.cpp
+++ b/libs/ui/mediatek/RefBaseDump.cpp
@@ -0,0 +1,112 @@
+#define LOG_TAG "RefBaseDump"
+
+#if 0
+#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
+#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
+#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
+#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
+#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
+#else
+#define RBD_LOGV(x, ...)
+#define RBD_LOGD(x, ...)
+#define RBD_LOGI(x, ...)
+#define RBD_LOGW(x, ...)
+#define RBD_LOGE(x, ...)
+#endif
+
+#include <cutils/log.h>
+#include <cutils/process_name.h>
+#include <cutils/properties.h>
+#include <ui/mediatek/RefBaseDump.h>
+
+namespace android {
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+
+RefBaseDump::RefBaseDump(RefBaseMonitor* pMonitor)
+    : mMonitor(pMonitor) {
+}
+
+RefBaseDump::~RefBaseDump() {
+}
+
+status_t RefBaseDump::kickDump(String8& result, const char* prefix) {
+    return mMonitor->dump(result);
+}
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(RefBaseMonitor)
+
+RefBaseMonitor::RefBaseMonitor() {
+    char value[PROPERTY_VALUE_MAX];
+    RBD_LOGI("RefBaseMonitor ctor - %p", this);
+    getProcessName();
+    property_get("debug.rb.dump", value, "Mary had a little lamb");
+    mIsTracking = (-1 != mProcessName.find(value));
+    mDump = new RefBaseDump(this);
+    DumpTunnelHelper::getInstance().regDump(mDump, String8::format("RB-%p", this));
+}
+
+RefBaseMonitor::~RefBaseMonitor() {
+    RBD_LOGI("RefBaseMonitor dtor - %p", this);
+    DumpTunnelHelper::getInstance().unregDump(String8::format("RB-%p", this));
+}
+
+status_t RefBaseMonitor::monitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    if (mIsTracking) {
+        pRb->trackMe(true, false);
+    }
+    RbList.add(pRb, 0);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::unmonitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    RbList.removeItem(pRb);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::dump(String8& result) {
+    int listSz;
+    RefBase *pRb;
+    Mutex::Autolock _l(mMutex);
+    RBD_LOGI("RefBaseMonitor Dump - %p", this);
+    listSz = RbList.size();
+    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
+    result.append(mIsTracking ? " <- tracking\n" : "\n");
+    result.append("\t  -----------------------\n");
+
+    for (int i = 0; i < listSz; i++) {
+        pRb = RbList.keyAt(i);
+        if (mIsTracking) {
+            pRb->printRefs();
+        }
+        result.appendFormat("\t   %2d) %8p %4d\n", i, pRb, pRb->getStrongCount());
+    }
+    result.append("\t*****************************************************\n");
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::getProcessName() {
+    int pid = getpid();
+    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
+    if (NULL != fp) {
+        const size_t size = 64;
+        char proc_name[size];
+        fgets(proc_name, size, fp);
+        fclose(fp);
+        mProcessName = proc_name;
+    } else {
+        mProcessName = "unknownProcess";
+    }
+    return NO_ERROR;
+}
+
+}
+
diff --git a/libs/ui/mediatek/test/Android.mk b/libs/ui/mediatek/test/Android.mk
index e69de29..82e7389 100644
--- a/libs/ui/mediatek/test/Android.mk
+++ b/libs/ui/mediatek/test/Android.mk
@@ -0,0 +1 @@
+#barrier
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
index e69de29..c984406 100644
--- a/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
@@ -0,0 +1,16 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    RefBaseDumpTunnel.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libui
+
+LOCAL_MODULE:= test-RefBaseDumpTunnel
+
+LOCAL_MODULE_TAGS := tests
+
+include $(BUILD_EXECUTABLE)
+
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
index e69de29..c248230 100644
--- a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
@@ -0,0 +1,106 @@
+#include <stdio.h>
+#include <time.h>
+#include <utils/StrongPointer.h>
+#include "RefBaseDumpTunnel.h"
+
+using namespace android;
+
+void RefBaseMonitorTest_Assignment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    sp<RefBaseTest> sp2;
+    //printf("[1]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+         sp2 = sp1;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+}
+
+void RefBaseMonitorTest_CtorDtor(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    RefBaseTest *rbtmp;
+    //printf("[2]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        rbtmp = new RefBaseTest();
+        delete rbtmp;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorTest_CtorDtorAssgnment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    //printf("[3]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        sp1 = new RefBaseTest();
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorSubTest (int testRound, int testCntPerRound, void (*testFunc)(int, struct timespec *, struct timespec *)) {
+    struct timespec tsS;
+    struct timespec tsE;
+    int tmp;
+    int totalCnt;
+    int timeWithTracking = 0;
+
+    for(int j = 0; j < testRound; j++) {
+        //printf("Rnd: %d",j);
+        (*testFunc)(testCntPerRound, &tsS, &tsE);
+
+        tmp = tsE.tv_nsec - tsS.tv_nsec;
+        if (tmp < 0) {
+            tmp = 1000000000L + tsE.tv_nsec - tsS.tv_nsec;
+        }
+        timeWithTracking += tmp;
+        //printf("with RefBaseTracking....D:%d(ns)\n",tmp);
+    }
+    totalCnt = testRound * testCntPerRound;
+    printf("%12d(ns) = TotalTime: %12d(ns) / TestCnt: %d \n", timeWithTracking / totalCnt, timeWithTracking, totalCnt);
+
+}
+
+void RefBaseMonitorTest(int recCount, int testRound, int testCntPerRound) {
+    int tmp = recCount;
+    if (recCount == 0) {
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_Assignment);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtor);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtorAssgnment);
+    } else {
+        recCount--;
+        RefBaseMonitorTest(recCount, testRound, testCntPerRound);
+    }
+    printf("(stack:%d)", tmp);
+}
+
+int main(int argc, char** argv) {
+    int recLv;
+    int testRound;
+    int testCntPerRound;
+    int recCntTime;
+
+    if (argc == 5) {
+        sscanf(argv[1], "%d", &recLv);
+        sscanf(argv[2], "%d", &recCntTime);
+        sscanf(argv[3], "%d", &testRound);
+        sscanf(argv[4], "%d", &testCntPerRound);
+        if ((recLv >= 0) && (recCntTime > 0) && (testRound > 0) && (testCntPerRound > 0)) {
+            for (int i = 0; i < recCntTime; i++) {
+                printf("\nrec[ n + %d ]\n", i + recLv);
+                RefBaseMonitorTest(i + recLv, testRound, testCntPerRound);
+            }
+            printf("\n\n");
+            return 0;
+        }
+    }
+    printf("test-RefBaseDumpTunnel recLv recTimes testRnd testCntPerRnd\n");
+    return 0;
+}
+
+
+
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
index e69de29..84f21b0 100644
--- a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
@@ -0,0 +1,18 @@
+#include <utils/RefBase.h>
+#include <ui/mediatek/RefBaseDumpTunnel.h>
+
+namespace android
+{
+
+class RefBaseTest: public RefBase{
+    public:
+        RefBaseTest(){
+            RefBaseMonitor::getInstance().monitor(this);
+        }
+        ~RefBaseTest(){
+            RefBaseMonitor::getInstance().unmonitor(this);
+        }
+};
+
+};
+
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 937665b..70c0d44 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -138,12 +138,13 @@ static const extention_map_t sExtensionMap[] = {
             (__eglMustCastToProperFunctionPointerType)&eglSignalSyncKHR },
     { "eglGetSyncAttribKHR",
             (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
-
+#ifndef MTK_HARDWARE
     // EGL_NV_system_time
     { "eglGetSystemTimeFrequencyNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
     { "eglGetSystemTimeNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
+#endif
 
     // EGL_KHR_wait_sync
     { "eglWaitSyncKHR",
@@ -1607,6 +1608,7 @@ EGLBoolean eglGpuPerfHintQCOM(EGLDisplay dpy, EGLContext ctx, EGLint *attrib_lis
 
 }
 
+#ifndef MTK_HARDWARE
 // ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
@@ -1627,6 +1629,7 @@ EGLuint64NV eglGetSystemTimeFrequencyNV()
 
     return setErrorQuiet(EGL_BAD_DISPLAY, 0);
 }
+#endif
 
 EGLuint64NV eglGetSystemTimeNV()
 {
